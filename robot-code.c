#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  activate_button, sensorTouch)
#pragma config(Sensor, dgtl2,  select_button,  sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lift_motor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           right_motor,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           left_motor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ping_motor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// constants for move function
#define FORWARD 1
#define REVERSE 2
#define LEFT 3
#define RIGHT 4
#define STOP 0

// constant definitions
#define WHEEL_CIRC 0.324 // diam = 0.103m (10.3cm) | 0.103*PI = 0.324m circ.
#define ROBOT_WIDTH 0.26 // 0.26m (26cm) wide
#define MOTOR_ENCODER_REV 627
#define PI 3.14159

// function signature definitions
void move(int dir, int speed);
void drop_the_ball();

void drive_one_m();
void quarter_rotate(int input_dir);

int test_select(int num_tests);
int test_cycle(int num_tests);
void run_test(int test);
void button_wait();

volatile int test = 0;

// MAIN
// -------------------------------
task main()
{
	while (true)
	{
		int test_pick = test_select(3);
		run_test(test_pick);
	}
}
// ---------------------------------

/*
Function:	Sets the motors to move the car in the specified direction
					and speed.
					- FORWARD
					- REVERSE
					- LEFT
					- RIGHT
					- STOP (default)
Inputs:		int dir - Specified direction of movement
					int speed - The speed of rotation of the motors
Return:		NA
*/
void move(int dir, int speed)
{
	int neg_speed = 0 - speed;

	switch (dir)
	{
		case 1:
			// move forward
			motor[right_motor] = speed;
			motor[left_motor] = speed;
			break;

		case 2:
			// move backward
			motor[right_motor] = neg_speed;
			motor[left_motor] = neg_speed;
			break;

		case 3:
			// rotate left
			motor[right_motor] = speed;
			motor[left_motor] = neg_speed;
			break;

		case 4:
			// rotate right
			motor[right_motor] = neg_speed;
			motor[left_motor] = speed;
			break;

		default:
			// stop motors
		motor[right_motor] = 0;
		motor[left_motor] = 0;
		break;
	}
}

// ---------------------------
// -- Milestone 1 Functions --
// ---------------------------

/*
Function:	Raise the release mechanism to drop the ball.
Inputs:		NA
Return:		NA
*/
void drop_the_ball()
{
	motor[lift_motor] = 20;
	wait1Msec(1200);
	motor[lift_motor] = 0;
	wait1Msec(2000);
	motor[lift_motor] = -20;
	wait1Msec(1000);
	motor[lift_motor] = 0;
}

/*
Function:	Move forward a distance of 1 meter.
Inputs:		NA
Return:		NA
*/
void drive_one_m()
{
	// 1 meter / circumference of wheel
	float wheel_revs = 1.0/WHEEL_CIRC;
	int pulses = wheel_revs * MOTOR_ENCODER_REV * -1;

	resetMotorEncoder(right_motor);

	move(FORWARD, 40);
	while (getMotorEncoder(right_motor) > pulses){/*do nothing*/}

	move(STOP, 0);
}

/*
Function:	Rotate the robot 90 degrees.
Inputs:		NA
Return:		NA
*/
void quarter_rotate(int input_dir)
{
	// dist along arc for 90 / circumference of wheel
	float wheel_revs = ((PI * ROBOT_WIDTH) / 4) / WHEEL_CIRC;
	int right_pulses = wheel_revs * MOTOR_ENCODER_REV;
	int left_pulses = right_pulses * -1;

	resetMotorEncoder(right_motor);

	move(input_dir, 30);

	// taking into account the direction of rotation of the encoder (+/-)
	if (input_dir != RIGHT) {
		while (getMotorEncoder(right_motor) > left_pulses){/*do nothing*/}
	} else {
		while (getMotorEncoder(right_motor) < right_pulses){/*do nothing*/}
	}


	move(STOP, 0);
}

// ---------------------------
// -- Helper Functions --
// ---------------------------
/*
Function:	Choose to either change test by pressing [select] button,
					or run test by pressing both buttons.
Inputs:		num_tests - The number of tests currently in the test pool.
Return:		int - Returns a number assiciated to the test we want to run.
*/
int test_select(int num_tests)
{
	int selection = 0;
	while (true)
	{
		// change current test
		if (SensorValue(select_button) == 1 && SensorValue(activate_button) == 0) {
			selection = test_cycle(num_tests);

		// choose current test as the one to run
		} else if (SensorValue(select_button) == 1 && SensorValue(activate_button) == 1) {
			wait1Msec(1500);
			return selection;
		}
	}
}

/*
Function:	Takes input from [activate] button.
					activate_button: Used to increment test to run.
Inputs:		num_tests - The number of tests currently in the test pool.
Return:		int - Returns a number assiciated to the test we want to run.
*/
int test_cycle(int num_tests)
{
	while (true)
	{
		// incriment to the next test
		if (SensorValue(select_button) == 0 && SensorValue(activate_button) == 1) {
			if (test == num_tests-1) test = 0;
			else test++;
			return test;
		}
	}
}

/*
Function:	Use for the purpose of testing the implementation
					of new functions.
Inputs:		int test - Identifies the test we want to run.
Return:		NA
*/
void run_test(int test)
{
	switch (test)
	{
		case 0:
			// testing drive 1 meter
			drive_one_m();

			break;

		case 1:
			// testing 90 degree rotate
			quarter_rotate(LEFT);
			wait1Msec(1500);
			quarter_rotate(RIGHT);

			break;

		case 2:
			// testing drop mechanism
			drop_the_ball();
			wait1Msec(1500);
			move(REVERSE, 20);
			wait1Msec(2000);
			move(STOP, 0);

			break;

		default:
			// do nothing
			break;
	}
}
