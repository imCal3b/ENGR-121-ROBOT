#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ir_sensorCL,    sensorReflection)
#pragma config(Sensor, in2,    ir_sensorLO,    sensorReflection)
#pragma config(Sensor, dgtl1,  button2,        sensorTouch)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl4,  stop_button,    sensorTouch)
#pragma config(Sensor, dgtl10, led,            sensorNone)
#pragma config(Sensor, dgtl11, ping_sensor,    sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lift_motor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           right_motor,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           left_motor,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          ping_motor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// constants for move function
#define FORWARD 1
#define REVERSE 2
#define LEFT 3
#define RIGHT 4
#define STOP 0

// constant definitions
#define WHEEL_CIRC 0.44 // diam = 0.103m (10.3cm) | 0.103*PI = 0.324m circ.
#define ROBOT_WIDTH 0.26 // 0.26m (26cm) wide
#define MOTOR_ENCODER_REV 627
#define PI 3.14159

#define LED_OFF 0
#define LED_ON 1

#define LED_F1 1
#define LED_F2 2
#define LED_F3 3

#define LONG_IR 0
#define SHORT_IR 1
#define IR_THRESHOLD 900

// function signature definitions
void move(int dir, int speed);
void slow(int cur_pulses, int tot_pulses, int final_speed, int start_speed);
void led_signal(int status);
void state_signal();

// milestone 1
void drop_the_ball();
void drive_one_m();
void quarter_rotate(int input_dir);

// milestone 2
void state_machine();
int scan_environment(int sensor);
int move_to_target();
int line_the_shot();

void ir_sensor_read(int sensor);
void narrow_search(int sensor, int speed);
void ping_sensor_test();

// helper functions
void run_test(int test);
int button_press();

// Global Variables
int state = 1;

int ir_LO_min = 4095;
int ir_CL_min = 4095;
int motorEncoder_pos = 0;
int ping_min_val = 9999;

// ---------------------------
// --------- Main ------------
// ---------------------------
task main()
{
	while (true){
		run_test(button_press());
	}
}

// ---------------------------
// -- Milestone 2 Functions --
// ---------------------------

/*
Function:
Inputs:		NA
Return:		NA
*/
void ping_sensor_test()
{
	move(FORWARD, 30);
	while (SensorValue(ping_sensor) > 500){/*do nothing*/}
	move(STOP, 0);

	state_signal();
}

/*
Function:
Inputs:		NA
Return:		NA
*/
int scan_environment(int sensor)
{
	float wheel_revs = (PI * ROBOT_WIDTH) / WHEEL_CIRC;
	int right_pulses = 1.4 * wheel_revs * MOTOR_ENCODER_REV;

	resetMotorEncoder(right_motor);

	move(RIGHT, 40);
	// Look for IR sensor reading
	while (getMotorEncoder(right_motor) < right_pulses){ir_sensor_read(sensor);}

	move(STOP, 0);
	wait1Msec(500);
	move(LEFT, 40);
	// Return to position of strongest signal position
	while (getMotorEncoder(right_motor) > motorEncoder_pos - 20){/*do nothing*/}

	move(STOP, 0);
	wait1Msec(100);

	ir_LO_min = 4095;
	ir_CL_min = 4095;

	//led_signal(LED_F1);
	return 2;
}

/*
Function:
Inputs:		NA
Return:		NA
*/
int move_to_target(int sensor)
{
	int count = 0;
	move(FORWARD, 30);
	while (SensorValue(ping_sensor) > 400)
	{
		ir_sensor_read(LONG_IR);

		if (count%1000 == 999)
		{
			if (ir_LO_min > IR_THRESHOLD) {
				narrow_search(sensor, 40);
				move(FORWARD, 30);
			}
			ir_LO_min = 4095;
			ir_CL_min = 4095;
		}

		count++;
	}
	move(STOP, 0);
	//led_signal(LED_F2);
	return 3;
}

/*
Function:
Inputs:		NA
Return:		NA
*/
int line_the_shot()
{
	narrow_search(LONG_IR, 40);
	wait1Msec(100);

	move(FORWARD, 15);
	while(SensorValue(ping_sensor) > 50 && SensorValue(stop_button) != 1){/*do nothing*/}
	move(STOP, 0);

	return 4;
}

/*
Function:
Inputs:		NA
Return:		NA
*/
void ir_sensor_read(int sensor)
{
	int ir_val = 0;
	switch (sensor)
	{
		// ---------- use LONG range IR detection (100k ohm) -----------
		case LONG_IR:
			for (int i=0; i<3 ;i++) {ir_val += SensorValue(ir_sensorLO);}
			ir_val /= 3;

			if ( ir_val < ir_LO_min && ir_val < IR_THRESHOLD)
			{
				ir_LO_min = ir_val;
				motorEncoder_pos = getMotorEncoder(right_motor);
				ping_min_val = SensorValue(ping_sensor);
			}
			break;

		// ---------- use SHORT range IR detection (1k ohm) ------------
		case SHORT_IR:
			for (int i=0; i<3 ;i++) {ir_val += SensorValue(ir_sensorCL);}
			ir_val /= 3;

			if ( ir_val < ir_CL_min && ir_val < IR_THRESHOLD)
			{
				ir_CL_min = ir_val;
				motorEncoder_pos = getMotorEncoder(right_motor);
				ping_min_val = SensorValue(ping_sensor);
			}
			break;
	}
}

/*
Function:
Inputs:		NA
Return:		NA
*/
void narrow_search(int sensor, int speed)
{
	ir_LO_min = 4095;
	ir_CL_min = 4095;

	move(STOP, 0);
	wait1Msec(100);
	resetMotorEncoder(right_motor);

	move(RIGHT, speed);
	// narrow search left
	while (getMotorEncoder(right_motor) < 100){ir_sensor_read(sensor);}

	move(STOP, 0);
	wait1Msec(500);

	move(LEFT, speed);
	// narrow search right
	while (getMotorEncoder(right_motor) > -100){ir_sensor_read(sensor);}

	move(STOP, 0);
	wait1Msec(500);

	move(RIGHT, speed-5);
	while(SensorValue(ping_sensor) > ping_min_val + 2){/*do nothing*/}

	move(STOP, 0);
}

/*
Function:
Inputs:		NA
Return:		NA
*/
void led_signal(int status) // Fix or change------------------------------
{
	switch (status)
	{
		case LED_OFF:
			SensorValue(led) = LED_OFF;
			break;

		case LED_F1:
			for (int i=0;i<4;i++)
			{
				SensorValue(led) = LED_ON;
				wait1Msec(125);
				SensorValue(led) = LED_OFF;
				wait1Msec(500);
			}
			break;

		case LED_F2:
			for (int i=0;i<4;i++)
			{
				for (int j=0;j<2;j++)
				{
					SensorValue(led) = LED_ON;
					wait1Msec(1000);
					SensorValue(led) = LED_OFF;
					wait1Msec(250);
				}
				wait1Msec(250);
			}
			break;

		case LED_F3:
			for (int i=0;i<4;i++)
			{
				for (int j=0;j<3;j++)
				{
					SensorValue(led) = LED_ON;
					wait1Msec(1000);
					SensorValue(led) = LED_OFF;
					wait1Msec(250);
				}
				wait1Msec(250);
			}
			break;
	}
}

/*
Function:
Inputs:		NA
Return:		NA
*/
void state_signal()
{
	motor[lift_motor] = 20;
	wait1Msec(500);
	motor[lift_motor] = -20;
	wait1Msec(500);
	motor[lift_motor] = 0;
}

/*
Function:
Inputs:		NA
Return:		NA
*/
void state_machine()
{
		switch (state)
	{
			case 1:
				state = scan_environment(LONG_IR);
				break;

			case 2:
				state_signal();
				state = move_to_target(LONG_IR);
				break;

			case 3:
				state_signal();
				state = line_the_shot();
				break;

			case 4:
				//drop_ball_on_target();
				break;

			case 5:
				//return_position();
				break;

			default:
				break;
	}
}

// ---------------------------
// -- Milestone 1 Functions --
// ---------------------------

/*
Function:	Raise the release mechanism to drop the ball.
Inputs:		NA
Return:		NA
*/
void drop_the_ball()
{
	motor[lift_motor] = 20;
	wait1Msec(1500);
	motor[lift_motor] = 0;
	wait1Msec(2500);
	motor[lift_motor] = -20;
	wait1Msec(1000);
	motor[lift_motor] = 0;
}

/*
Function:	Move forward a distance of 1 meter.
Inputs:		NA
Return:		NA
*/
void drive_one_m()
{
	// 1 meter / circumference of wheel
	float wheel_revs = 1.0/WHEEL_CIRC;
	int pulses = wheel_revs * MOTOR_ENCODER_REV * -1;

	resetMotorEncoder(right_motor);

	move(FORWARD, 25);
	while (getMotorEncoder(right_motor) > pulses)
	{
		if (getMotorEncoder(right_motor) < (pulses + 627))
		{
			slow(getMotorEncoder(right_motor), pulses, 20, 25);
		}
	}

	move(STOP, 0);
}

/*
Function:	Rotate the robot 90 degrees.
Inputs:		NA
Return:		NA
*/
void quarter_rotate(int input_dir)
{
	// dist along arc for 90 / circumference of wheel
	float wheel_revs = ((PI * ROBOT_WIDTH) / 4) / WHEEL_CIRC;
	int right_pulses = 1.2 * wheel_revs * MOTOR_ENCODER_REV;
	int left_pulses = right_pulses * -1;

	resetMotorEncoder(right_motor);

	move(input_dir, 40);

	// taking into account the direction of rotation of the encoder (+/-)
	if (input_dir != RIGHT) {
		while (getMotorEncoder(right_motor) > left_pulses){/*do nothing*/}
	} else {
		while (getMotorEncoder(right_motor) < right_pulses){/*do nothing*/}
	}

	move(STOP, 0);
}

/*
Function:	Sets the motors to move the car in the specified direction
					and speed.
					- FORWARD
					- REVERSE
					- LEFT
					- RIGHT
					- STOP (default)
Inputs:		int dir - Specified direction of movement
					int speed - The speed of rotation of the motors
Return:		NA
*/
void move(int dir, int speed)
{
	int neg_speed = 0 - speed;

	switch (dir)
	{
		case 1:
			// move forward
			motor[right_motor] = speed;
			motor[left_motor] = speed;
			break;

		case 2:
			// move backward
			motor[right_motor] = neg_speed;
			motor[left_motor] = neg_speed;
			break;

		case 3:
			// rotate left
			motor[right_motor] = speed;
			motor[left_motor] = neg_speed;
			break;

		case 4:
			// rotate right
			motor[right_motor] = neg_speed;
			motor[left_motor] = speed;
			break;

		default:
			// stop motors
		motor[right_motor] = 0;
		motor[left_motor] = 0;
		break;
	}
}

// ---------------------------
//   -- Helper Functions --
// ---------------------------

/*
Function:	Slows the speed of the robot when it gets within
					a certain range of an object.
Inputs:		int cur_pulses - the current state of the getMotorEncoder().
					int tot_pulses - the exit condition when the car should stop.
					int final_speed - the specified final speed for the robot to slow to.
					int start_speed - the initial speed before starting to slow.
Return:		NA
*/
void slow(int cur_pulses, int tot_pulses, int final_speed, int start_speed)
{
	int diff_pulses = 0 - tot_pulses + cur_pulses;
	int diff_speed = start_speed - final_speed;

	int new_speed = start_speed - (diff_speed - (diff_pulses / 627)*diff_speed);

	if (new_speed < final_speed) new_speed = final_speed;

	move(FORWARD, new_speed);
}

/*
Function:	Use for the purpose of testing the implementation
					of new functions.
Inputs:		int test - Identifies the test we want to run.
Return:		NA
*/
void run_test(int test)
{
	wait1Msec(1500);
	switch (test)
	{
		case 0:
			// tests locate and move to position
			while (state != 4)
			{
				state_machine();
			}
			break;

		case 1:
			// tests wall detection
			ping_sensor_test();

			break;

		default:
			// do nothing
			break;
	}
}

int button_press()
{
	while (true)
	{
		if (SensorValue(button1) == 1) return 0;
		if (SensorValue(button2) == 1) return 1;
		if (SensorValue(button3) == 1) return 2;
	}
}
